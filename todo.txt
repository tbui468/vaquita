TODO:
    May be easier to rewrite tree functions
        If a current node is full, rather than trying to balance, just add a new empty node to the right
        If adding a new node to the right will result in a full node, add a new node to the parent (repeat up to root if necessary)
        This won't be efficient if nodes are deleted, but we can deal with that later
        This method will be simplier and faster than trying to rebalance everytime since we are only adding to the right

    Adding 85 records should split 2 nodes into 3 (rather than creating a new level)

    _tree_traverse_to already gives the height of each node (heights are same as index)
        When a node is full, ALL keys on that level need to be rebalanced.  Only add
        a new node at that level if all nodes are above some capacity threshold

        complete _tree_rebalance_internals
        struct IndexList _tree_get_nodes_at_depth(struct VdbPager* pager, FILE* f, uint32_t depth) <----START HERE
            May need to make another function to call recursively

    Need to rebalance trees at some point since the auto-incrementing primary key will make tree
        Add a ton of entries and check tree height
        right side heavy at some point.  Check tree balance after inserting record to see if
        rebalance is necessary

    Deleting records
        Should keys be reused?  How does sqlite do it?

    Switch to binary search in _tree_traverse_to_leaf (just using linear scan right now)

    Limit how many blocks are in buffer cache at a time - use least-recently used eviction policy

    Refactor code to make it more readable - splitting leaves is a mess now

    Allow fetch to get range of records by primary key - first step into creating an execution engine here

    How to implement execution engine:
        SQL parser and VM to run the bytecode

