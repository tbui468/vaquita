    Efficiency of dbms can be estimated with number IO operations

    Use gdb to walk through code (Cherno recommended debugger to learn to read code)
        https://www.cs.yale.edu/homes/aspnes/pinewiki/C(2f)Debugging.html
        Try it on the xv6 (or the risc-v version) - would gdb even work with vm?

    https://github.com/firstcontributions/first-contributionsool
        go to this link and do a basic contribution

    Use ChatGPT to help write paper on neural network to learn
        eviction policy for pager - integration of neural networks
        into legacy code

    Use Yahoo or some other database standard metric to focus on core features

    cstack.github.io for short guide to basics of SQL implementation (not complete)

    Read Edward Sciore's book on implementing a relational database
        Chapter 4: Memory Management (PDF 92)

    Use SDL and Vulkan to visualize SQL + b-tree (2d first, and then 3d)
        visualize how b-tree grows and nodes split as new entries are added
        visualize how tree is traversed as data is queried
        use ipc (?) to have two programs talk to each other:
            use vdb REPL to modify database
            run visualization program to read vdb data to visualize it

    sqlite documentation has great explanation of how bytecode works

***********************Documentation*****************************
Example
Major components
Todos

**********************************Client**************************
The dbms should run as a server (rather than embedded) and have a scheduler that
    gives connecting clients the illusion that they have sole access to the dbms

    Seems like mysql uses tcp sockets

    Some basic SQL implemented in parser:
        vdb > connect 3000;
        vdb > show databases;
        vdb > create database school;
        vdb > open school;
        
        vdb:school > show tables;
        vdb:school > create table students (name string, age int, grad bool);
        vdb:school > describe students;
        vdb:school > insert into students (name, age, male) values ("Bob", 12, true);
        vdb:school > insert into students (name, age, male) values ("Kate", 13, false), ("John", 14, true);
        vdb:school > update students set name = "Jim", age = 12, male = true where id = 2;
        vdb:school > delete from students where id = 1;
        vdb:school > select * from students;
        vdb:school > select id, name from students;
        vdb:school > select id, name, male from students where age >= 12;
        vdb:school > drop table students;
        vdb:school > close school;

        vdb > drop database school;
        vdb > exit;

*******************************TODO**************************************************
    add error checking to parser
        this will be trickier since we need to exit early if error occurs
        if error occurs, skip all tokens until past semicolon (or end of token list), and try to continue parsing
        will NOT execute code if any lexing/parsing errors occur, but good to give user some error message

    vdbparser_next_token will not check token type - when is this needed???

        If an error is spotted, throw away the rest of the statement (until the semicolon)
            How to do this?  Exiting current statement is easy, but how to exit current expression
                when an error is encountered

    Include semicolon at end of each statement
        Handle lexing/parsing errors
            next_token(parser) - go to next token without error checking
            consume_token(parser, type) - expect a certain type
            peek_token(parser) - just look without going to next token

            Give the user useful messages rather than segfaulting


    parse, print and execute these statements
        VDBST_SHOW_DBS - need to create function for this
        VDBST_CREATE_DB - will need to split vdb_open into create/open versions
        VDBST_SHOW_TABS - will need to create function for this
        VDBST_DESCRIBE_TAB -create function for this
        VDBST_DROP_DB - create function for this (just delete the directory)
        VDBST_CONNECT - make this a stub for now

    Implement execute for these:
        update
        delete
        select <----this will require a fair bit of work

    Schema should use enum VdbTokenType for data types rather than enum VdbField

    Good chance to add VdbData types rather than using c-types
        mainly this will allow NULL type

    Connect cli and the database tree to get useful data - play with MariaDB or MySQL to see how they print outputs
        > open school
            database school opened
        > select * from students
            +----+------+-----+
            | id | name | age |
            +----+------+-----+
            |  1 | John |  23 |
            |  2 | Kate |  12 |
            |  3 | Timm |  22 |
            +----+------+-----+
            3 rows in set
        > close school
            database school closed
            [what message?]

    Test making multiple trees - insert and fetch data from multiple trees (tables)

    Vdb Data Types - need this to allow NULL to be a value (specifically, represent the absence of a value)

    Cursor abstraction - would this be helpful as the intermediary between vdb.c and tree.c?
        will we need to know which attribute to index by? (primary key should be default)
        vdbcursor_to_end()
        vdbcursor_to(key)
        vdbcurosr_next()

    pager eviction policy
        make db really big so that the program crashes because of too much memory allocated, then evict pages to fix it
        Or just manually limit number of pages allowed to hold at a time
        Use O_DIRECT to bypass OS pager

    Foreign keys to connect two or more tables
        joins will be needed here

    Custom keys
        Unique or not?
        Have to rewrite tree to split/merge based on where inserted (since it will not be in order anymore)

    Concurrency - need to get read/write locks on file

    Transactions - need a way of rolling back changes if transaction fails

    Logging - database should never be in inconsistent state if system fails

************************Execution Engine**********************

    Execution engine
        selection WHERE
        projection SELECT 

        See SQL-92 for the standard to quality as 'supporting SQL'

        Foreign keys

