TODO:
    Use gdb to walk through code (Cherno recommended debugger to learn to read code)
        https://www.cs.yale.edu/homes/aspnes/pinewiki/C(2f)Debugging.html
        Try it on the xv6 (or the risc-v version) - would gdb even work with vm?

    _tree_init_intern should NOT call _tree_init_leaf
        have the caller do that separately, and then have the caller wire the indices to reference each other if necessary
        
        Test that this refactor works before trying to split internals again - save on git too

    Idea: splitting leaves and internals restructures the tree, so any U32List* idx_list may be invalid
        so have functions restructure idx_list in place

        Make _tree_split_intern return a U32List while writing and testing it
            Or better yet, modify the idx_list in place
        Refactor code to make _tree_split_leaf also return a U32List

    Note: Need to release all nodes before we start modifying a tree (this was problem with why split_leaf was not working)
        if not, then releasing old nodes later may overwrite changes

        How about this: when a node is current used, set a flag somewhere in it
            if this flag is set, assert false so that we know that we know that it's a problem

    Adding record with key 211 fills up current internal (also happens to be root) and seg faults
        Split internal node when full
            This should be called when splitting leaves (if adding a new leaf fills internal parent)

    Adding records
        Adding records now is not check if leaf is full
            if full, need to add new leaf to the right
                if a leaf can't be added, add a new internal node to the right
                    if internal is already root, create new root and make the old root the left child.  Then add new right child

    Fetching records

    Deleting records
        Should keys be reused?  How does sqlite do it? - sqlite allows reuse if user desires

    Switch to binary search in _tree_traverse_to_leaf (just using linear scan right now)

    Limit how many blocks are in buffer cache at a time - use least-recently used eviction policy

    Refactor vdb.c to make it more readable - it's a bit messy now

    Allow fetch to get range of records by primary key - first step into creating an execution engine here

    How to implement execution engine:
        SQL parser and VM to run the bytecode

