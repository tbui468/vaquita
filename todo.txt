    Efficiency of dbms can be estimated with number IO operations

    Use gdb to walk through code (Cherno recommended debugger to learn to read code)
        https://www.cs.yale.edu/homes/aspnes/pinewiki/C(2f)Debugging.html
        Try it on the xv6 (or the risc-v version) - would gdb even work with vm?

    https://github.com/firstcontributions/first-contributionsool
        go to this link and do a basic contribution

    Use ChatGPT to help write paper on neural network to learn
        eviction policy for pager - integration of neural networks
        into legacy code

    check out nandgame for website on how to create processor from scratch
        then try to do it using verilog

    Use Yahoo or some other database standard metric to focus on core features

    cstack.github.io for short guide to basics of SQL implementation (not complete)

    Read Edward Sciore's book on implementing a relational database
        Chapter 4: Memory Management (PDF 92)

    Use SDL and Vulkan to visualize stars/planets/moons in galaxy

    sqlite documentation has great explanation of how bytecode works

    handmade.network has cool mini projects (such as barebones OS with only a few thousand lines of C)

***********************Documentation*****************************
Example
Major components
Todos

*******************data****************************

Use sample data to make sure SQL kinda works
    https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html
    also look at moons/rings/comets/asteroids fact sheets

        create table planets
        create table moons
        create table rings
        create table comets
        create table asteroids

*******************************TODO**************************************************
    node.c/h should not know about internal structure of struct VdbDatum
        caller (tree) should just pass in size or request pointer of where a record starts
        uint32_t vdbdata_append_datum(uint8_t* buf, struct VdbDatum* datum, uint32_t* len_written)
            this function should be:
                //attempst to allocated requested size, and will set allocated_size to what was possible
                //returns the index of the index cell
                uint32_t vdbdata_allocate_new_string_space(uint8_t* buf, uint32_t requested_size, uint32_t* allocated_size);

                //caller (tree) should then write as much of string as possible and then allocate more space if needed
                //caller then writes data to buffer (as musch as allocated_size)
                uint8_t* vdbdata_get_string_ptr(uint8_t* buf, uint32_t idxcell_idx);

                loop to allocate more space/write more data as needed in tree.c

    Fill in testing suite and framework - this will make catching regressions a lot more efficient
        Have expected test results for each test so outputs can be checked
            create_db.sql
                check that [name].vdb is created
            create_tab.sql
                check that [name].vtb is inside of [db].vdb
            drop_db.sql
                check that [name].vdb is NOT there (should create one db and then drop it)
            drop_tab.sql
                check that [name].vtb is NOT there (should create table and then drop it)
            describe.sql
                check that output is correct (table name + attributes + types)
            drop_db_ifexists.sql
                check case where db exists, and where db doesn't exist
            drop_tab_ifexists.sql
                check case where table exists and where table doesn't exist
            insert_count.sql
                check that output shows correct number of records inserted
            Note: use 'select * from ...' output to test these
                insertion with all attributes defined:
                    insert_primary_key.sql
                        use select to make sure primary key increments correct
                    insert_strings.sql
                        use select to make sure all strings are read correctly
                    insert_int.sql
                        check ints
                    insert_bool.sql
                        check bools
                    insert_float.sql
                        check floats
                    insert_null.sql
                        check nulls
                insertion with automatic insertion of nulls for undefined attributes:
                    insert_default_null_string.sql
                        automated insertion of null for undefined strings   
                    insert_default_null_int.sql
                        automated insertion of null for undefined strings
                
            
        Add python script to run tests
  
    Remove key field in record and in node- this is now a regular attribute in records now
        will need to rewrite some functions that read keys from node buffers

    single line comments
        use c-style //

    multiline comments
        use c-style /**/

    Don't need to specify column names if inserting all values
        insert into planets values (...), (...);

    Need to look at memory - measure what is allocated  
        make a static variable that tracks allocated memory in allocation wrapper functions
        make a wrapper for free() and use that everywhere - decrememnt memory 
        print out memory usage at end to see what is still allocated
        when incrementing/decrementing memory allocation, wrap in debug macro to turn off later

    If block size is 256 and block header size is 128, it crashes if not enough room to store schema data
        the attribute names take too much space.  Need an overflow block for attribute strings.

    cursor abstraction:
        cursors are created when starting a new transaction, and destroyed when transaction ends (commit or not)
        a cursor is associated with a table AND an ordering (eg, by which column the records are indexed)
        a cursor has a closed and open state:
            <open stmt> opens a cursor
            <close stmt>, <commit stmt>, or <rollback stmt> closes cursor
        cursor may be before first record or one past the last record
        fetch - moves cursor to next record and returns that record
        delete - deletes record pointed to by cursor - moves cursor to next record after deletion
        update - updates records pointed to by cursor

    to update
        struct VdbCursor* cursor = vdbcursor_init_at(h, table_name, key);
        initialize a cursor at key
        write record there

    to delete
        make sure increment skips deleted records
        initialize a cursor at key
        delete record there

    add more test cases
        use python to automate running of program with test scripts
        **Do this before writing bytecode generator and vm

    Compile AST to bytecode that runs on vm
        How could this work?
            what instructions are needed?
        when inserting, attribute names should be parsed as expressions (being parsed as single tokens now)
            can remove parse_identifier_tuple function then

            insert into planets (name, mass) values ("Mars", 242), ("Venus", 242), ("Earth", 534);

        
    need checks to prevent table manipulation/creation/dropping when database not open - segfaulting now

    need to return error if table doesn't exist when insert/select/update/delete - segfaulting now

    pager eviction policy
        make db really big so that the program crashes because of too much memory allocated, then evict pages to fix it
        Or just manually limit number of pages allowed to hold at a time
        Use O_DIRECT to bypass OS pager

    Concurrency - need to get read/write locks on file
        pager can take care of this

    Transactions - need a way of rolling back changes if transaction fails
        need a way to track undos (a stack???)

    Logging - database should never be in inconsistent state if system fails
        sqlite uses a write-ahead log


    Connect cli and the database tree to get useful data - play with MariaDB or MySQL to see how they print outputs
        > open school
            database school opened
        > select * from students
            +----+------+-----+
            | id | name | age |
            +----+------+-----+
            |  1 | John |  23 |
            |  2 | Kate |  12 |
            |  3 | Timm |  22 |
            +----+------+-----+
            3 rows in set
        > close school
            database school closed
            [what message?]

    Foreign keys to connect two or more tables
        joins will be needed here

    Custom keys
        Unique or not?
        Have to rewrite tree to split/merge based on where inserted (since it will not be in order anymore)

    views

    unique constraint

    not null constraint

    group by

    joins
    
    split into client and server - use tcp sockets to connect client to server
