TODO: Storage engine
    switch to B-Tree - this will make more sense when switching to a paging system
    _vdb_rebalance_tree - need to rebalance trees after insertion/deletion
        find algorithm to compute height of a given subtree - then use this to determine whether to rotate right or left
    switch to B-Tree (or B+-Tree) - rewrite interface between tree/vdb if necessary to ease future tree implementation changes
    Pager - tree should request blocks from pager
        a single page holds only a single node?  (Any extra data will be in overflow pages)
        this will make more sense if using a B-Tree rather than a binary tree
    virtual machine for running straightline code (which we need to define)
        predicates and combinations of it will be useful here
    How to compile SQL to produce straight line code to run in vm
    Make it a distributed system - add network support

Vaquita Relational Database
    vdb.c
        vdb_open(struct DB* db, const char* name); - opens a database with given name
        vdb_create_table(struct DB* db, const char* table_name, enum Field* fields, int field_count); - adds table to database with given schema
        vdb_drop_table(struct DB* db, const char* table_name);
        vdb_insert_record(struct DB* db, const char* table_name, ...); - number/type of variable arguments must match table schema
        vdb_delete_record(struct DB* db, const char* table_name, int key);
        vdb_get_by_primary_key(struct DB*, uint64_t primary_key); - get table record by id //will add SQL query engine later

    tree.c - tree grabs blocks it needs and will need to figure out offsets to get proper tree data/metadata
        vdb_tree_read(struct DB* db, int off, uint8_t* buf, int len) { //this should be atomic
            //compute correct block index
            vdb_pager_read_lock();
            struct Block* b = vdb_pager_read_block(correct block index);
            //do whatever necessary to b
            vdb_pager_un_lock();
        }
        vdb_tree_write(struct DB* db, int off, uint8_t* buf, int len) { //this should be atomic
            //compute correct block index
            vdb_pager_write_lock();
            struct Block* b = vdb_pager_read_block(correct block index);
            //write data to b
            vdb_pager_write_block(index);
            vdb_pager_un_lock();
        }

        other functions for traversing tree and finding free records

    pager.c - pager only knows about blocks
        vdb_pager_read_lock(struct DB* db, int off, int len);
        vdb_pager_write_lock(struct DB* db, int off, int len);
        vdb_pager_un_lock(struct DB* db, int off, int len);
        vdb_pager_read_block(struct Block* b, int idx);
        vdb_pager_write_block(struct Block* b, int idx, uint8_t* buf, int len);



Database Internals
    Chapter 1: Introduction and Overview (PDF 27)
        What is the difference between row and column oriented data layouts?
            row-oriented stores data in tuples
            column stores data by fields
        Is a wide column store the same as a column-oriented database?
            No, but I'm not sure what wide column store is
        What is the difference between a primary and secondary key?
            Primary key (usually incremented integer) points to data
            Secondary key either references primary key OR references data (depending on implementation)

    Chapter 2: B-Tree Basics (PDF 45)
        How can a rotation step be used to keep a binary tree balance?
            Change root if one side is higher
        How are fanout and height of a tree related?
            fanout are how many children per node.  More children, less height (give the same number of nodes)
        Why is sequential vs random I/O access not as important in SSDs compared to HDDs?
            Spinning head in HDD is super slow, so access sequential sectors on disk is a fair bit faster
            SSDs uses cells, so it's not a big of a deal (but sequential is still faster here too)
        What is a 2-3 tree?
            Two indices, and three children per node
        What is the difference between a B-Tree and B+-Tree?
            B-Trees store data in internal and leaf nodes, and B+-Trees only store them in leaves
        When does a node need to be split?
            Too many children (over a set max capacity)
        When does splitting cause the B-Tree to grow in height?
            When splitting a node cause the root to need to be split too
        When should nodes be merged?
            When children count in under a set threshhold
    
    Chapter 3: File Formats (PDF 65)
        What is a slotted layout?
        In a slotted layout page, how are pointers and cells related?
        How are nodes and pages related?  (eg, how many nodes per page?)
        What mechanisms can be used to ensure (at least attempt) data was not accidentally corrupted?

    Chapter 4: Implementing B-Trees (PDF 81)
        What can magic numbers be used for? 
        What are sibling links, and why are they useful?
        What are overflow pages?
        Why are breadcrumbs used with B-Trees, and what data structure is commonly used to store breadcrumbs?
        Why are nodes 'rebalanced' instead of merged/split sometimes?
        What are right-only appends?
        What is bulk-loading and how does it relate to right-only appends?
        What's the purpose of compressing data?
        What is compaction/vacuum/maintenance?

    Chapter 5: Transaction Processing and Recovery (PDF 99)
        
Designing Data-Intensive Applications
    Chapter 1: Reliable, Scalable, and Maintainable Applications (PDF 15)


























